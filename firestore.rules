rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if a user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Users: Allow any authenticated user to read profiles, but only the owner can write.
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && request.auth.uid == userId;
    }

    // Projects:
    // list: Allow any authenticated user to perform the query for their projects.
    // read: Allow if the user's UID is in the project's member list.
    // write: Allow any authenticated user to create/update (for joining/leaving).
    // delete: Only the owner can delete.
    match /projects/{projectId} {
      // The client-side query contains the security clause (where('memberUids', 'array-contains', uid))
      // so we just need to ensure the user is logged in to run a query.
      // Firestore then checks the 'read' rule for each document returned.
      allow list: if isAuthenticated();

      // This is the key fix: Use resource.data directly instead of a self-referential get()
      allow read: if isAuthenticated() && request.auth.uid in resource.data.memberUids;
      
      // Allow create/update for any authenticated user. Logic for joining/creating is in server actions.
      allow write: if isAuthenticated(); 
      
      // Only the project owner can delete the project document.
      allow delete: if isAuthenticated() && resource.data.ownerUid == request.auth.uid;
    }

    // Project Sub-collections (Observations, Inspections, PTWs)
    match /projects/{projectId}/{collection}/{docId} {
      // Use the parent project's data to verify membership.
      // The `get()` here is efficient as it only reads the parent document once per sub-collection access.
      allow read, write: if isAuthenticated() && get(/databases/$(database)/documents/projects/$(projectId)).data.memberUids.includes(request.auth.uid);
    }

    // Root-level collections for private/public items.
    match /observations/{docId} {
      // This rule applies to the root 'observations' collection.
      
      // PUBLIC: Anyone can read. Authenticated users can update (for likes, etc.).
      allow read: if resource.data.scope == 'public';
      allow update: if isAuthenticated() && resource.data.scope == 'public';

      // PRIVATE: Only the user who created the document can read or write it.
      allow read, write: if isAuthenticated() && resource.data.userId == request.auth.uid && resource.data.scope == 'private';
    }
     match /inspections/{docId} {
      // PRIVATE: Only the user who created the document can read or write it.
      allow read, write: if isAuthenticated() && resource.data.userId == request.auth.uid && resource.data.scope == 'private';
    }
     match /ptws/{docId} {
      // PRIVATE: Only the user who created the document can read or write it.
      allow read, write: if isAuthenticated() && resource.data.userId == request.auth.uid && resource.data.scope == 'private';
    }
  }
}
